             +--------------------------+
             |          CS 212          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Eva Batelaan       <batelaan@stanford.edu>
Kenny Oseleononmen <kenny1g@stanford.edu>
Akram Sbaih        <akram@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Used to pass info concerning the process' name and arguments from 
process_execute() to load(), where the stack is intitiated.

struct process_info {
  char *cmd_line;           /* Pointer to the cmd line of args on the heap. */
  char *progam_name;        /* Pointer to the program name (first arg). */
  struct semaphore loaded;  /* Prevents the thread from running until process
                               info is loaded in the stack */
}

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

process_execute() uses thread_create() to call start_process() which calls 
load(). The stack of the thread is set up in load(), so we have to make sure 
the stack is created and the args are put into the stack before the thread
starts to run. Therefore, we chose to used a sempahore that would block the
thread until it had been fully loaded, and then we could up it so that it could
run. We needed to be able to pass information from 
process_execute() to thread_create() and something that could hold the
aforementioned needed semaphore, so we created the process_info struct.

We parsed the arguments and passed them into the stack after the stack was
created in the load() function. We arrange for elements of argv[] to be in the 
right order using the following steps:
 - pushing filename and arg strings onto the stack in order
 - word aligning to 4 bytes 
 - starting w nullptr, pushing the references to the args on the stack in 
   reverse order
 - then push argv, argc, and return address onto the stack

We avoid overflowing stack page by allocating our process_info stuct on the 
heap. We only allocate a page for the purposes of this project, so have to 
limit the file name and args to PGSIZE. However, since we're adding more than
just the file name and args, (we're also adding their references, argc, etc.)
we make sure to not overflow the stack by making sure we're within the
boundaries of the thread's stack whenever we write to it.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

According to the man page, strtok_r() is a reentrant version of strtok(). 
strtok() uses a static buffer while parsing to keep track of the point from 
which to start searching for the next token. However, strtok_r() has an extra 
argument, saveptr, which is used internally to maintain context between 
succecessive calls that parse the same string. Because strtok_r() maintains
state between calls internally through the extra argument rather than with a
global static variable, strtok_r() is MT-safe, which means it is safe to call 
in the presence of other threads, whereas strtok() is MT-Unsafe, so it invokes 
undefined behavior if a context switch happens while strtok() is called and 
another thread calls strtok(). However, strtok_r() should not be called by 
mutiple threads on the same string because strtok_r() modifies the string.
 
>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

The UNIX approach scopes arguemnt handling more appropriately, handling  
parsing in the shell keeps all argument parsing client-side. This isolation
helps prevents introducing additional complexity and bugs in the kernel. It 
shoudln't be the kerenel's job to parse arguments since there is no reason it
can't be done on the user side. Also if the argument parsing results in a
crash, it's better to crash the shell than the kernel.

The Pintos approach is also just a more naive implementation. Since Pintos 
just parses the command lines as tokens separated by white space, it cannot 
handle additional complexity within arguments, such as differentiating between 
an argument starting with '-' vs one starting with '--'. However, the UNIX 
shell can easily handle parsing more complicated argument structures.

                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

FOR GENERAL:
typedef bool list_find_func (struct list_elem *elem, void *aux);
    Prototype for a generic helper function for `list_find` which returns 
    true for the ELEM that we want to find in some list.

MEMBERS IN STRUCT THREAD:
char *process_fn;
    Copy of the filename running in this process. Used to print the exit message on
    process_exit.
int32_t process_exit_code;
    Stores the exit code of the current thread to be printed on process_exit.
struct process_child *inparent;
    Pointer to a datastructure living in the parent process to reflect the status of 
    this current child process. Set to NULL if parent is dead. Protected with the 
    process_child_lock lock.
struct list process_children;
    List of datastructures reflecting the status of all child processes, including dead
    ones. Protected by the process_child_lock lock.

LOCKS:
static struct lock process_child_lock;
    Global lock protecting all accesses to members inparent and process_children for
    all threads.

PROCESS EXEC/WAIT:
struct process_child {
  struct thread *thread;
  struct list_elem elem;
  int32_t exit_code;
  struct semaphore exited;
};
    Datastructre to keep track of the status of one child in parent thread->process_children.
    THREAD points to the child process struct thread if child is still alive.
    ELEM appends datastrcture to the parent thread->process_children.
    EXIT_CODE exit code of this child.
    EXITED up'd when the child exits.

SYSCALL INFRASTRUCTURE:
#define SYSCALL_CNT SYS_INUMBER + 1
    The number of supported syscalls. SYS_INUMBER is the syscall with the biggest index.
typedef void syscall_handler_func (struct intr_frame *);
    Protoype of a syscall handler function dispatched for some syscall.
static syscall_handler_func *syscall_handlers[SYSCALL_CNT];
    A list of supported syscall's mapping the syscall number to its syscall_handler_func.

FOR DENY WRITES:
To allow us to properly deny writes, we added a file pointer to the executable
file that spawened the process to the thread struct. 
 `struct file* exec_file;             /* The file that spawned this process*/`

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.
We implemneted two helper functions as follows:
    static void syscall_validate_user_memory (const void *uaddr, size_t size)
    static void syscall_validate_user_string (const char *uaddr, size_t max_size);
These functions check that an address is 
  1. Not NULL
  2. Below PHYS_BASE
  3. Mapped with the process pagedir
  4. Same 3 apply to entire block of SIZE bytes following UADDR.
If any of these conditions is not met, it terminates the user process and frees its
resources. 
These functions are used to validate user memory at given addresses before attempting
to read or write on them. The following function uses them to extract arguments passed
from the user process stack.
    static uint32_t syscall_get_arg (struct intr_frame *f, size_t idx)
Which validates and reads memory at the appropriate index relative to %esp.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?
Our current implementation relies on the function syscall_validate_user_memory which 
takes an address and a block size. It then iterates page by page over that block of 
memory and checks the validity of each page only once. Therefore, if the user is passing
a page-size block, we will need either one or two calls to pagedir_get_page because the
page-sized block might be broken into two virtual pages. If the user is copying 2 bytes
of data, we still need either one or two calls. Because the 2 bytes might live on the
end and the beginning of two different virtual pages. Given that we need to check each
virtual page individually, there's no room for further improvement on this end. 

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.
We use the `struct process_child` to keep track of the status of child processes.
When `wait` is called. We first find the child in `thread->process_children` 
corresponding to the TID passed protected by the `process_child_lock` lock.
If it's found, we down the `exited` semaphore in `process_child` which is only up'd 
after the child process terminates. 
Finally, we remove the child from the children list and return its `exit_code` 
from `process_child` before freeing the memory of the `process_child` struct.
On the other hand, when a process exits, it acquires the `process_child_lock` and up's
its `process_child` `exited` semaphore. It also updates the `process_child` exit_code 
and `thread` appropriately. 
Finally, it updates the `inparent` member of all its children processes to point to NULL
and frees their `process_child` memory. These orphaned child processes don't need to update
their parent when they exit in the future. 

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.
Decomposition helps with this problem. Our approach is to define `syscall_validate_user_memory`
which is called on every memory block we try to access on the user memory. This function
is designed to never return if called on invalid memory. If that happens, it calls 
`syscall_terminate_process` which frees all process resources and exits it. 
For example, when `syscall_write` is called. `syscall_get_arg` calls `syscall_validate_user_memory`
on the corresponding address on the user stack. Then `syscall_validate_user_memory` is called
on the provided buffer address by the user for the provided size. If any of these validations
fails, `syscall_terminate_process` is called which then frees all dynamic memory (e.g. process
filename, process children, etc.). If any new features are added that require freeing memory on
termination, they should be added to this function.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?
We use a `thread->loaded` semaphore which is down'd on a call to exec (so
it never returns until it unblocks by being up'd) and up'd when the process
is loaded successfully. 

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?
P waits for C before C exits:
    P blocks on the `sema_down(child->exited)` until that semaphore is up'd 
    in the child. This datastructure is protected by `process_child_lock`.
P waits for C after C exits:
    When C had exited, it had up'd its child semaphore protected by 
    `process_child_lock` and therefore when P calls wait, it down's the 
    semaphore without needing to block and returns.
P terminates before C exits:
    When P terminates, it free's all memory assiciated with its children in 
    `thread->process_children` and sets their `inparent` to NULL. This lets
    them know that they are orphaned when they exit so they don't need to update
    tehir dead parent. All these operations are protected by the `process_child_lock`.
P terminates after C exits:
    When P terminates, it frees all its `thread->process_children` memory. However,
    because its children member `THREAD` is NULL, it doesn't need to let them know
    that they are orphaned (and it shouldn't because their `struct thread` memory 
    had already been free'd).
This design is very modular that it doesn't need to account for any further edge cases.


---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?
We choose this way because it's sematically simple. There is a clear list of conditions on
valid memory that are followed in sequence. Other implementations such as modifying the 
exception handler for pagefault offer higher effeciency. However, such implementation 
involves wide changes and assumptions across different parts of the OS which makes it 
complicated. 
Our implementation also abstract away the termination of the process if it violates memory
and frees its resources automatically should it detect a violation.

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?
We haven't changed it.

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
