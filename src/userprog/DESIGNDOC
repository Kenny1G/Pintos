             +--------------------------+
             |          CS 212          |
             | PROJECT 2: USER PROGRAMS |
             |     DESIGN DOCUMENT      |
             +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Eva Batelaan       <batelaan@stanford.edu>
Kenny Oseleononmen <kenny1g@stanford.edu>
Akram Sbaih        <akram@stanford.edu>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.

               ARGUMENT PASSING
               ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Used to pass info concerning the process' name and arguments from
process_execute() to load(), where the stack is intitiated.

struct process_info {
  char *cmd_line;           /* Pointer to the cmd line of args on the heap. */
  char *progam_name;        /* Pointer to the program name (first arg). */
  struct semaphore loaded;  /* Prevents the thread from running until process
                               info is loaded in the stack */
}

---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

process_execute() uses thread_create() to call start_process() which calls
load(). The stack of the thread is set up in load(), so we have to make sure
the stack is created and the args are put into the stack before the thread
starts to run. Therefore, we chose to used a sempahore that would block the
thread until it had been fully loaded, and then we could up it so that it could
run. We needed to be able to pass information from process_execute() to
thread_create() and something that could hold the aforementioned needed
semaphore, so we created the process_info struct.

We parsed the arguments and passed them into the stack after the stack was
created in the load() function. We arrange for elements of argv[] to be in the
right order using the following steps:
 - pushing filename and arg strings onto the stack in order
 - word aligning to 4 bytes
 - starting w nullptr, pushing the references to the args on the stack in
   reverse order
 - then push argv, argc, and return address onto the stack

We avoid overflowing stack page by allocating our process_info stuct on the
heap. We only allocate a page for the purposes of this project, so have to
limit the file name and args to PGSIZE. However, since we're adding more than
just the file name and args, (we're also adding their references, argc, etc.)
we make sure to not overflow the stack by making sure we're within the
boundaries of the thread's stack whenever we write to it.

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

According to the man page, strtok_r() is a reentrant version of strtok().
strtok() uses a static buffer while parsing to keep track of the point from
which to start searching for the next token. However, strtok_r() has an extra
argument, saveptr, which is used internally to maintain context between
succecessive calls that parse the same string. Because strtok_r() maintains
state between calls internally through the extra argument rather than with a
global static variable, strtok_r() is MT-safe, which means it is safe to call
in the presence of other threads, whereas strtok() is MT-Unsafe, so it invokes
undefined behavior if a context switch happens while strtok() is called and
another thread calls strtok(). However, strtok_r() should not be called by
mutiple threads on the same string because strtok_r() modifies the string.
 
>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

<<<<<<< Updated upstream
=======
The UNIX approach scopes arguemnt handling more appropriately, handling
parsing in the shell keeps all argument parsing client-side. This isolation
helps prevents introducing additional complexity and bugs in the kernel. It
shoudln't be the kerenel's job to parse arguments since there is no reason it
can't be done on the user side. Also if the argument parsing results in a
crash, it's better to crash the shell than the kernel.

The Pintos approach is also just a more naive implementation. Since Pintos
just parses the command lines as tokens separated by white space, it cannot
handle additional complexity within arguments, such as differentiating between
an argument starting with '-' vs one starting with '--'. However, the UNIX
shell can easily handle parsing more complicated argument structures.

>>>>>>> Stashed changes
                 SYSTEM CALLS
                 ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

<<<<<<< Updated upstream
=======
FOR DENY WRITES:
To allow us to properly deny writes, we added a file pointer to the executable
file that spawened the process to the thread struct.
 `struct file* exec_file;             /* The file that spawned this process*/`

>>>>>>> Stashed changes
>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

               SURVEY QUESTIONS
               ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
